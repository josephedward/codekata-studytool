[
  {
    "category": "Pod Management",
    "prompts": [
      {
        "prompt": "Create a pod named nginx using the nginx image and expose port 80",
        "response": "kubectl run nginx --image=nginx --port=80",
        "explanation": "Invokes `kubectl run` to create a new Pod resource called `nginx`, fetching the official `nginx` image from the default registry. The `--port=80` flag tells Kubernetes to annotate the Pod’s spec with a container port of 80, which downstream Services or port-forwarding commands can use to route traffic. This is a quick way to spin up a standalone web server Pod for development or smoke-testing purposes; in production you’d typically wrap it in a Deployment or Service for high availability and load balancing."
      },
      {
        "prompt": "Create a pod named busybox that runs the command 'sleep 3600'",
        "response": "kubectl run busybox --image=busybox -- sleep 3600",
        "explanation": "Uses `kubectl run` to launch a Pod named `busybox` with the lightweight `busybox` image, overriding the default container entrypoint to execute `sleep 3600`. This is useful for creating a temporary container that stays alive for an hour, allowing you to `kubectl exec` in and inspect cluster networking or volume mounts without the Pod exiting immediately."
      },
      {
        "prompt": "Generate a YAML definition file for a pod named nginx without creating it",
        "response": "kubectl run nginx --image=nginx --dry-run=client -o yaml > nginx.yaml",
        "explanation": "Leverages the `--dry-run=client` option to validate and render the Pod manifest locally without sending anything to the API server. Combining this with `-o yaml` outputs the full Pod spec—name, image, ports, etc.—to stdout, and redirecting (`> nginx.yaml`) saves it as `nginx.yaml`. You can then review or modify the file before applying it with `kubectl apply -f` for more controlled deployments."
      },
      {
        "prompt": "Create a pod that runs the latest nginx image and sets an environment variable DB_URL=postgresql://db",
        "response": "kubectl run nginx --image=nginx --env=\"DB_URL=postgresql://db\"",
        "explanation": "Executes `kubectl run` to spin up an `nginx` Pod using the `nginx:latest` image, injecting the environment variable `DB_URL` into the container’s process environment. This approach is handy when you need to pass configuration (like database connection strings) at runtime, though for production workloads you may prefer mounting a Secret or ConfigMap instead of embedding sensitive data directly on the command line."
      },
      {
        "prompt": "Extract the YAML definition of a running pod named 'webapp' in the 'development' namespace",
        "response": "kubectl get pod webapp -n development -o yaml > webapp.yaml",
        "explanation": "Runs `kubectl get pod webapp -n development` to retrieve the live Pod object from the API server in the `development` namespace, then formats it as YAML with `-o yaml`. Redirecting the output to `webapp.yaml` captures the full spec, status, and metadata, which you can diff against your source manifests to debug drift or resource misconfigurations."
      },
      {
        "prompt": "Create a pod with labels app=web and tier=frontend",
        "response": "kubectl run nginx --image=nginx --labels=\"app=web,tier=frontend\"",
        "explanation": "Invokes `kubectl run` to create a Pod named `nginx`, tagging it with the labels `app=web` and `tier=frontend`. Labels are key/value pairs attached to objects, used by Services, Deployments, and other controllers for grouping, selecting, and organizing resources. This pattern helps with traffic routing (e.g., Service selectors) and operational tasks like `kubectl get pods -l tier=frontend`."
      },
      {
        "prompt": "Create an interactive temporary pod with Ubuntu image to troubleshoot cluster issues",
        "response": "kubectl run my-shell --rm -i --tty --image=ubuntu -- bash",
        "explanation": "Creates a single-use Pod named `my-shell` using the `ubuntu` image, launching an interactive Bash session. The `--rm` flag ensures Kubernetes deletes the Pod automatically as soon as you exit the shell, while `-i --tty` attaches your terminal’s stdin and stdout. This is ideal for ad-hoc debugging, allowing you to inspect cluster DNS, test network connectivity, or probe volumes without leaving behind garbage Pods."
      },
      {
        "prompt": "Create a pod with resource requests of 100m CPU and 256Mi memory",
        "response": "kubectl run nginx --image=nginx --dry-run=client -o yaml > pod.yaml # Then add requests specification",
        "explanation": "Generates a Pod manifest for `nginx` with `--dry-run=client -o yaml`, which you can edit to include `resources.requests.cpu: \"100m\"` and `resources.requests.memory: \"256Mi\"`. Resource requests inform the scheduler of the minimum CPU and memory the Pod needs to run, aiding in efficient packing of workloads and ensuring QoS guarantees under contention. After editing, apply with `kubectl apply -f pod.yaml`."
      },
      {
        "prompt": "Create a pod that runs curl against an internal service at 10.244.0.4",
        "response": "kubectl run curl1 --image=curlimages/curl -i -t --rm --restart=Never -- curl 10.244.0.4",
        "explanation": "Launches a one-off Pod named `curl1` using the `curlimages/curl` image, immediately executing `curl 10.244.0.4`. Flags `-i -t` attach your terminal, `--rm` auto-deletes the Pod post-execution, and `--restart=Never` prevents Kubernetes from trying to restart it on exit. This lets you validate internal connectivity to the service IP directly from within the cluster."
      },
      {
        "prompt": "Create a pod that mounts a ConfigMap named 'app-config' as a volume at '/etc/config'",
        "response": "kubectl run config-pod --image=busybox --dry-run=client -o yaml > pod.yaml # Then add volume mount configuration",
        "explanation": "Produces a skeleton Pod manifest which you then augment under `spec.volumes` to reference `configMap.name: app-config` and under `spec.containers[0].volumeMounts` to mount it at `/etc/config`. Mounting a ConfigMap as a volume allows the Pod to load configuration files or environment settings at runtime without baking them into the container image."
      }
    ]
  }
]